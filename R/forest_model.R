#' Produce a forest plot based on a regression model
#'
#' @param model regression model produced by \code{\link[stats]{lm}},
#'   \code{\link[stats]{glm}}, \code{\link[survival]{coxph}}
#' @param panels \code{list} with details of the panels that make up the plot (See Details)
#' @param exponentiate whether the numbers on the x scale should be exponentiated for plotting
#' @param format_options formatting options as a list as generated by \code{\link{forest_model_format_options}}
#' @param funcs optional list of functions required for formatting \code{panels$display}
#' @param factor_separate_line whether to show the factor variable name on a separate line
#' @param theme theme to apply to the plot
#' @param limits limits of the forest plot on the X-axis (taken as the range of the data
#'   by default)
#' @param breaks breaks to appear on the X-axis (note these will be exponentiated
#'   if \code{exponentiate == TRUE})
#' @param return_data return the data to produce the plot as well as the plot itself
#' @param covariates a character vector optionally listing the variables to include in the plot
#'   (defaults to all variables)
#' @param recalculate_width \code{TRUE} to recalculate panel widths using the current device
#'   or the desired plot width in inches
#' @param recalculate_height \code{TRUE} to shrink text size using the current device
#'   or the desired plot height in inches
#' @param model_list list of models to incorporate into a single forest plot
#' @param merge_models if `TRUE`, merge all models in one section.
#' @param exclude_infinite_cis whether to exclude points and confidence intervals
#'   that go to positive or negative infinity from plotting. They will still be
#'   displayed as text. Defaults to \code{TRUE}, since otherwise plot is malformed
#' @param show_global_p Show model global p value, only works for Cox model.
#' - 'none', don't show.
#' - 'bottom', show global p value in the bottom.
#' - 'aside', show global p value along with 'Reference', this is useful when you plot a list of models.
#' @param n_logical_true_only whether to only count TRUE values in n for logical
#'   covariates
#'
#' @return A ggplot ready for display or saving, or (with \code{return_data == TRUE},
#'   a \code{list} with the parameters to call \code{\link{panel_forest_plot}} in the
#'   element \code{plot_data} and the ggplot itself in the element \code{plot})
#'
#' @details This function takes the model output from one of the common model functions in
#'   R (e.g. \code{\link[stats]{lm}}, \code{\link[stats]{glm}},
#'  \code{\link[survival]{coxph}}). If a \code{label} attribute was present on any of the
#'  columns in the original data (e.g. from the \code{labelled} package),
#'  this label is used in preference to the column name.
#'
#'  The \code{panels} parameter is a \code{list} of lists each of which have an element
#'  \code{width}
#'  and, optionally, \code{item}, \code{display}, \code{display_na},
#'  \code{heading}, \code{hjust} and \code{fontface}. \code{item} can be \code{"forest"} for the forest
#'  plot (exactly one required) or \code{"vline"} for a vertical line.
#'  \code{display} indicates which column to display as text. It can be a quoted variable name
#'  or a formula. The column display can include the standard ones produced by
#'  \code{\link[broom]{tidy}} and in addition
#'  \code{variable} (the term in the model; for factors this is the bare variable without the  level),
#'  \code{level} (the level of factors),
#'  \code{reference} (TRUE for the reference level of a factor). For \code{\link[survival]{coxph}}
#'  models, there will also be \code{n_events} for the number of events in the group with
#'  that level of the factor and \code{person_time} for the person-time in that group.
#'  The function \code{trans} is definded to be the
#'  transformation between the coefficients and the scales (e.g. \code{exp}). Other functions not
#'  in base R can be provided as a \code{list} with the parameter \code{funcs}.
#'  \code{display_na} allows for an alternative display for NA terms within \code{estimate}.
#'
#' @import dplyr
#' @import ggplot2
#' @import rlang
#'
#' @export
#'
#' @examples
#'
#' library(survival)
#' library(dplyr)
#' pretty_lung <- lung %>%
#'   transmute(time,
#'     status,
#'     Age = age,
#'     Sex = factor(sex, labels = c("Male", "Female")),
#'     ECOG = factor(lung$ph.ecog),
#'     `Meal Cal` = meal.cal
#'   )
#'
#' print(forest_model(coxph(Surv(time, status) ~ ., pretty_lung)))
#'
#' # Example with custom panels
#'
#' panels <- list(
#'   list(width = 0.03),
#'   list(width = 0.1, display = ~variable, fontface = "bold", heading = "Variable"),
#'   list(width = 0.1, display = ~level),
#'   list(width = 0.05, display = ~n, hjust = 1, heading = "N"),
#'   list(width = 0.05, display = ~n_events, width = 0.05, hjust = 1, heading = "Events"),
#'   list(
#'     width = 0.05,
#'     display = ~ replace(sprintf("%0.1f", person_time / 365.25), is.na(person_time), ""),
#'     heading = "Person-\nYears", hjust = 1
#'   ),
#'   list(width = 0.03, item = "vline", hjust = 0.5),
#'   list(
#'     width = 0.55, item = "forest", hjust = 0.5, heading = "Hazard ratio", linetype = "dashed",
#'     line_x = 0
#'   ),
#'   list(width = 0.03, item = "vline", hjust = 0.5),
#'   list(width = 0.12, display = ~ ifelse(reference, "Reference", sprintf(
#'     "%0.2f (%0.2f, %0.2f)",
#'     trans(estimate), trans(conf.low), trans(conf.high)
#'   )), display_na = NA),
#'   list(
#'     width = 0.05,
#'     display = ~ ifelse(reference, "", format.pval(p.value, digits = 1, eps = 0.001)),
#'     display_na = NA, hjust = 1, heading = "p"
#'   ),
#'   list(width = 0.03)
#' )
#' forest_model(coxph(Surv(time, status) ~ ., pretty_lung), panels)
#'
#' data_for_lm <- tibble(
#'   x = rnorm(100, 4),
#'   y = rnorm(100, 3, 0.5),
#'   z = rnorm(100, 2, 2),
#'   outcome = 3 * x - 2 * y + 4 * z + rnorm(100, 0, 0.1)
#' )
#'
#' print(forest_model(lm(outcome ~ ., data_for_lm)))
#'
#' data_for_logistic <- data_for_lm %>% mutate(
#'   outcome = (0.5 * (x - 4) * (y - 3) * (z - 2) + rnorm(100, 0, 0.05)) > 0.5
#' )
#'
#' print(forest_model(glm(outcome ~ ., binomial(), data_for_logistic)))
forest_model <- function(model,
                         panels = NULL,
                         covariates = NULL, exponentiate = NULL, funcs = NULL,
                         factor_separate_line = FALSE,
                         format_options = forest_model_format_options(),
                         theme = theme_forest(),
                         limits = NULL, breaks = NULL, return_data = FALSE,
                         recalculate_width = TRUE, recalculate_height = TRUE,
                         model_list = NULL, merge_models = FALSE, exclude_infinite_cis = TRUE,
                         show_global_p = c("none", "bottom", "aside"),
                         n_logical_true_only = FALSE) {
  show_global_p <- match.arg(show_global_p)
  mapping <- aes(estimate, xmin = conf.low, xmax = conf.high)
  if (!is.null(model_list)) {
    if (!is.list(model_list)) {
      stop("`model_list` must be a list if provided.")
    }
    if (is.null(names(model_list))) {
      model_names <- rep("", length(model_list))
    } else {
      model_names <- names(model_list)
    }
    if (any(model_names == "")) {
      need_names <- which(model_names == "")
      model_names_needed <- vapply(model_list[need_names], function(x) quo_name(x$call), character(1))
      model_names[need_names] <- model_names_needed
    }
    if (!merge_models) {
      mapping <- c(mapping, aes(section = model_name))
    }
    if (is.null(exponentiate)) {
      exponentiate <- inherits(model_list[[1]], "coxph") ||
        (inherits(model_list[[1]], "glm") && model_list[[1]]$family$link == "logit")
    }
  } else {
    if (is.null(exponentiate)) {
      exponentiate <- inherits(model, "coxph") ||
        (inherits(model, "glm") && model$family$link == "logit")
    }
  }

  if (exponentiate) trans <- exp else trans <- I

  if (!is.null(panels) && !is.list(panels)) {
    stop("panels should be a list")
  }

  make_forest_terms <- function(model) {
    forest_terms_basic <- make_forest_terms_basic(model)

    tidy_model <- broom::tidy(model, conf.int = TRUE)
    data <- stats::model.frame(model)
    mmtrx <- stats::model.matrix(model)

    if (inherits(model, "coxph")) {
      # Cope with the way survival:::model.frame.coxph drops attributes from factors
      data_for_labels <- model_frame_coxph_simple(model)
    } else {
      data_for_labels <- data
    }

    forest_labels <- tibble::tibble(
      variable = names(data_for_labels),
      label = vapply(
        data_for_labels,
        function(x) attr(x, "label", exact = TRUE) %||% NA_character_,
        character(1)
      ) %>%
        coalesce(variable)
    )

    xlevels <- c(model$xlevels, lapply(which(vapply(data, is.logical, logical(1))), function(x) c(FALSE, TRUE)))

    create_term_data <- function(term_row) {
      out <- tibble::as_tibble(term_row)
      blank_row <- tibble::as_tibble(
        out,
        term = term_label,
        level = NA,
        level_no = NA,
        n = sum(!is.na(cols)),
        total = n,
        level_heading = FALSE
      )
      if (is.na(term_row$inc_factor)) {
        out <- blank_row
      } else {
        cols <-
          mmtrx[, attr(mmtrx, "assign") == term_row$term_number, drop = FALSE]
        if (term_row$inc_factor) {
          if (!any(colnames(cols) %in% tidy_model$term)) {
            # Filter out terms not in final model summary (e.g. strata)
            out <- blank_row
          } else {
            if (!term_row$is_interaction) {
              ref_level <- xlevels[[term_row$variable]][1]
              ref_level_term <-
                paste0(term_row$term_label, ref_level)
              if (!(ref_level_term %in% colnames(cols))) {
                cols <- cbind(data[, term_row$variable] == ref_level, cols)
                colnames(cols)[1] <- ref_level_term
              }
            }
            tab <- colSums(cols > 0)
            out <- tibble::tibble(
              out,
              term = names(tab),
              level = names(tab),
              level_no = 1:length(tab),
              n = tab,
              total = nrow(mmtrx),
              level_heading = FALSE
            )
            if (inherits(model, "coxph")) {
              event_detail_tab <- lapply(
                setNames(seq_len(ncol(model$y)), colnames(model$y)),
                function(y_col) {
                  apply(
                    cols,
                    2,
                    function(x_var) {
                      sum(model$y[x_var > 0, y_col])
                    }
                  )
                }
              ) %>%
                bind_cols()
              if (ncol(event_detail_tab) == 3) {
                event_detail_tab <- cbind(event_detail_tab[, 2] - event_detail_tab[, 1], event_detail_tab[, 3])
              }
              colnames(event_detail_tab) <-
                c("person_time", "n_events")
              out <- cbind(out, event_detail_tab)
            }
            if (factor_separate_line) {
              out <- bind_rows(tibble::as_tibble(term_row), out)
            }

            if (term_row$is_logical) {
              if (!n_logical_true_only) {
                out$n <- sum(out$n)
              }
              out <- out[grepl("TRUE$", out$level), ]
              out$level <- NA
            }
            if (term_row$is_interaction) {
              interaction_terms <- term_row$interaction_terms[[1]]
              interaction_levels <- lapply(
                seq_along(interaction_terms),
                function(i) {
                  if (term_row$interaction_terms_are_factors[[1]][i]) {
                    ilv <- tibble::tibble(
                      level = model$xlevels[[remove_backticks(interaction_terms[i])]],
                      label = paste0(interaction_terms[i], level)
                    )
                  } else {
                    ilv <- tibble::tibble(level = NA, label = interaction_terms[i])
                  }
                  colnames(ilv) <- paste0(colnames(ilv), "_", i)
                  ilv
                }
              )

              interaction_level_table <- Reduce(function(x, y)
                inner_join(x, y, by = character()),
                interaction_levels)
              interaction_level_table_cur_level <-
                interaction_level_table %>%
                select(starts_with("label")) %>%
                apply(1, paste, collapse = ":")

              interaction_levels_final <- interaction_level_table %>%
                select(starts_with("level"))
              interaction_levels_final <- interaction_levels_final[term_row$interaction_terms_are_factors[[1]]]
              colnames(interaction_levels_final) <- paste0("level_", 1:ncol(interaction_levels_final))
              interaction_levels_final$cur_level <- interaction_level_table_cur_level

              out <- left_join(
                out,
                interaction_levels_final %>%
                  select(-starts_with("label")),
                by = c("level" = "cur_level")
              )
              interaction_col_headers_data <- tibble::tibble(variable = term_row$interaction_vars[[1]][term_row$interaction_terms_are_factors[[1]]]) %>%
                left_join(forest_labels, by = "variable") %>%
                mutate(label = coalesce(label, variable))
              interaction_col_headers <- interaction_col_headers_data$label
              names(interaction_col_headers) <- paste0("level_", seq_along(interaction_col_headers))
              out <- bind_rows(
                tibble::tibble(
                  tibble::as_tibble(term_row),
                  !!!interaction_col_headers,
                  level_heading = TRUE
                ),
                out
              )
            } else {
              out$level <- substr(out$level, nchar(term_row$term_label) + 1, nchar(out$level))
            }
          }
        } else {
          out <- tibble::tibble(
            out,
            term = term_label,
            level = NA,
            level_no = NA,
            n = sum(rowSums(!is.na(cols)) > 0),
            total = nrow(mmtrx),
            level_heading = FALSE
          )
        }
      }
      if (!("level_1" %in% colnames(out)) && ("level" %in% colnames(out))) {
        out$level_1 <- out$level
      }
      out
    }
    forest_terms <- lapply(seq_len(nrow(forest_terms_basic)), function(i) create_term_data(forest_terms_basic[i, ])) %>%
      bind_rows() %>%
      filter(!is.na(variable)) %>%
      left_join(tidy_model, by = "term") %>%
      mutate(
        reference = ifelse(is.na(level_no), FALSE, level_no == 1 & !is_interaction),
        estimate = ifelse(reference, 0, estimate),
        variable = ifelse(is.na(variable), remove_backticks(term), variable)
      ) %>%
      mutate(
        variable = ifelse(is.na(level_no) | is_logical | (level_no == 1 & !factor_separate_line & !is_interaction), variable, NA)
      ) %>%
      left_join(
        forest_labels,
        by = "variable"
      ) %>%
      mutate(
        variable = coalesce(label, variable)
      )
    if (!is.null(covariates)) {
      forest_terms <- filter(forest_terms, term %in% covariates)
    }

    if (show_global_p != "none") {
      if (inherits(model, "coxph")) {
        p_val <- as.numeric(summary(model)$sctest[3])
        if (show_global_p == "bottom") {
          label <- paste("Global p", format.pval(p_val, digits = 1, eps = 1e-3))
          forest_terms <- forest_terms %>%
            dplyr::add_row(term_label = "Global p", variable = label)
        } else if (show_global_p == "aside") {
          if (length(unique(forest_terms$term_label)) > 1) {
            warning("It is not recommended to show global p value aside 'reference' if there is more than 1 variable.\nThey share the same p value.", immediate. = TRUE)
          }
          forest_terms$p.value[forest_terms$reference] <- p_val
        }
      }
    }

    forest_terms
  }

  if (!is.null(model_list)) {
    forest_terms <- lapply(seq_along(model_list), function(i) {
      make_forest_terms(model_list[[i]]) %>%
        mutate(model_name = model_names[i])
    }) %>%
      bind_rows()
    if (merge_models) {
      forest_terms$model_name <- NULL
    }
  } else {
    forest_terms <- make_forest_terms(model)
  }

  if (is.null(panels)) {
    panels <- default_forest_panels(model, factor_separate_line = factor_separate_line)
  }


  # #use_exp <- grepl("exp", deparse(trans))
  if (!is.null(limits)) {
    forest_terms <- forest_terms %>%
      mutate(
        arrow_tag.l = limits[1],
        arrow_tag.r = limits[2],
        arrow_tag.l = ifelse(conf.low < .data$arrow_tag.l, TRUE, FALSE),
        arrow_tag.r = ifelse(conf.high > .data$arrow_tag.r, TRUE, FALSE)
      ) %>%
      mutate(
        plot_range.low = ifelse(.data$arrow_tag.l, limits[1], conf.low),
        plot_range.high = ifelse(.data$arrow_tag.r, limits[2], conf.high)
      )
  }



  plot_data <- list(
    forest_data = forest_terms,
    mapping = mapping,
    panels = panels, trans = trans,
    funcs = funcs, format_options = format_options, theme = theme,
    limits = limits, breaks = breaks, recalculate_width = recalculate_width,
    recalculate_height = recalculate_height, exclude_infinite_cis = exclude_infinite_cis
  )
  main_plot <- do.call("panel_forest_plot", plot_data)
  if (return_data) {
    list(plot_data = plot_data, plot = main_plot)
  } else {
    main_plot
  }
}

remove_backticks <- function(x) {
  gsub("^`|`$|\\\\(?=`)|`(?=:)|(?<=:)`", "", x, perl = TRUE)
}

make_forest_terms_basic <- function(model) {
  mdl_terms <- stats::terms(model)
  term_labels <- attr(mdl_terms, "term.labels")
  mdl_factors <- attr(mdl_terms, "factors")
  mdl_data_classes <- attr(mdl_terms, "dataClasses")[remove_backticks(rownames(mdl_factors))]
  mdl_data_classes_factors <- mdl_data_classes %in% c("logical", "factor", "character")
  names(mdl_data_classes_factors) <- names(mdl_data_classes)

  mdl_terms_inc_factors <- colSums((mdl_factors == 1) & (mdl_data_classes_factors[remove_backticks(rownames(mdl_factors))])) > 0
  mdl_terms_are_logical <- colMeans((mdl_factors == 0) | (mdl_data_classes == "logical")) == 1
  forest_terms_basic <- tibble::tibble(
    term_number = 1:length(term_labels),
    term_label = term_labels,
    variable = remove_backticks(term_label),
    inc_factor = mdl_terms_inc_factors[term_label],
    is_logical = mdl_terms_are_logical,
    is_interaction = colSums(mdl_factors) > 1,
    interaction_terms = lapply(term_label, function(tl) names(which(attr(mdl_terms, "factors")[, tl] == 1))),
    interaction_vars = lapply(interaction_terms, remove_backticks),
    interaction_terms_are_factors = lapply(interaction_vars, function(iv) mdl_data_classes_factors[iv])
  )
}
